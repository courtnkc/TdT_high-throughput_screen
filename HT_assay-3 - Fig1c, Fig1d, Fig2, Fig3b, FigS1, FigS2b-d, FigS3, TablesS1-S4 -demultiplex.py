"""
This script was part of the pipeline used to generate data shown in Figures 1c, 1d, 2, 3b, S1, S2b-d, and S3. It also produced the data provided in Tables S1-S4.
Inputs for this script are the .fastq files generated by "HT_assay-2 - Fig1c, Fig1d, Fig2, Fig3b, FigS1, FigS2b-d, FigS3, TablesS1-S4 -filter_Gs.py" and a .fasta of multiplexing barcodes (forward and reverse barcodes, both 5'-3').
Outputs from this script are .fastq files with reads demultiplexed.

*All F barcodes must be the same length as each other.
*All R barcodes must be the same length as each other.
*Make sure to delete generated files between each run of the program.
"""

from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
from Bio import pairwise2
from Bio.pairwise2 import format_alignment
from Bio import Align
from Bio import SeqIO
import numpy as np
import multiprocessing as mp
import datetime
import os
import time
import shutil
import re
local = True


##### USER INPUTS #####

dirname = r'/pub/courtnkc/courtnkc20032557/5-25-20-Demultiplexing_full_scale_data' 
#the fastq file to be analyzed and the multiplexing barcode files are inputted at the end of this script

##### END USER INPUTS #####


print(datetime.datetime.now())
#changes current directory to the directory listed above, copies script to that directory with datestamp
if local == True:
    os.chdir(dirname)
    copied_script_name = time.strftime("%Y-%m-%d") + '_' + os.path.basename(__file__) 
    shutil.copy(__file__, dirname + os.sep + copied_script_name)


##### DEFINING FUNCTIONS #####

#given a sequence (A), a list of other sequences of the same length as A, and an int (N), returns a list of all sequences from the list that have at most N mismatches with A

def threshold_mismatch_align(seq, candidateSeqs, maxMismatches):
    
    goodSeqs = []
    
    for ref in candidateSeqs:
        matches = 0
        for c1,c2 in zip(seq, ref): #this is a simple alignment that just checks for perfect matches
            if c1 == c2:
                matches += 1
                
        mismatches = len(ref) - matches
        
        if mismatches <= maxMismatches:
            goodSeqs.append(ref)        
    
    return goodSeqs                     
            


def allSameLength(itemList):
    itemLengths = [len(item) for item in itemList]
    return all(x == itemLengths[0] for x in itemLengths) #all() returns true if the stuff inside is true


def createBarcodesDict(bcFASTA):

    '''
    function that creates a dictionary of barcodes from a fasta barcodes must be in the form: 

    >Name
    barcode

    Identifying information for Name must come after the letter 'e' as in 'barcode'
    function will then create a dictionary of these barcodes in the form barcode:Name
    '''

    bcDict = {}
    for record in SeqIO.parse(bcFASTA, 'fasta'):
        bcName = record.id.split('e')[1]
        bc = record.seq
        bcDict[bc] = bcName
    
    return bcDict

def sortByBarcodes(seqsIn, FbcFASTA, RbcFASTA):
    FbcDict = createBarcodesDict(FbcFASTA)
    FbcList = list(FbcDict.keys())
    RbcDict = createBarcodesDict(RbcFASTA)
    RbcList = list(RbcDict.keys())

    #get length of barcode from barcodeDict and confirm all are same length
    FbcLength = len(FbcList[0])
    RbcLength = len(RbcList[0])
    
    assert allSameLength(FbcList) and allSameLength(RbcList)    #if barcodes are all same length, it keeps going.  If not, it throws an error.

    SpecialSort = 0     #counts how many times the code that deals with my TdT library barcoded primers that have similar barcodes and therefore require special filtering (R3 and R4) is used
    
    #open files for read and write
    #opens and appends to each file one by one.
    #fqIn = open(seqsIn, 'r')
    outFilesDict = {} #dictionary to be filled with keys of tuples for the forward and reverse barcode names, and values as append files using these names
    for Fbc in FbcList:
        FbcName = FbcDict[Fbc]
        for Rbc in RbcList:
            RbcName = RbcDict[Rbc]
            outFilesDict[(FbcName,RbcName)] = open(f'{seqsIn.split(".f")[0]}_{FbcName}_{RbcName}.fastq','a') #names the output file to be the same as the input, plus Fbc, Rbc names. 
    fileName = seqsIn.split('.f')[0]
    badRecords = open(fileName+'_failed.fastq', 'a')

    #set fastq parsing index, loop through lines of fastq, save lines to variables which will be written to new sorted fastq later
    #every four lines, identify the barcode and write four lines to appropriate output file

    for record in SeqIO.parse(seqsIn, 'fastq'):

        #assign sequence to Bio Seq object, forward and reverse barcodes to separate variables
        seq = record.seq
        Fbc = seq[:FbcLength]   #slices first 6 bp from the fastq read (or however long the barcode is)
        Rbc = (seq[-RbcLength:]).reverse_complement()   #slices last 6 bp from the fastq read (or however long the barcode is)

        #find name of barcode, if barcode not in dict then try identifying barcode with 1 mismatch
        #only use the result if only one match is found
        try:
            FbcName = FbcDict[Fbc]
        except:
            matchedFbcList = threshold_mismatch_align(Fbc, FbcList, 1)  #specify max mismatches here!
            if len(matchedFbcList) != 1:    #checks if there's only one matched barcode to the read
                SeqIO.write([record], badRecords, 'fastq')
                continue
            else:
                matchedFbc = matchedFbcList[0]  #grabs the barcode sequence from the output of threshold_mismatch_align
                FbcName = FbcDict[matchedFbc]   #gets the name of the barcode
        try:
            RbcName = RbcDict[Rbc]
        except:
            matchedRbcList = threshold_mismatch_align(Rbc, RbcList, 1)  #specify max mismatches here!

            if len(matchedRbcList) != 1:        #checks if there's only one matched barcode to the read
                if len(matchedRbcList) == 2:    #corrects for possible mixups between 021_R4 and 022_R3 barcodes within my TdT libraries
                    if all(x in [Seq('TTGGCA'), Seq('TTGCCA')] for x in matchedRbcList):
                        SpecialSort += 1
                        if int(FbcName) == 3:
                            RbcName = '3'
                        elif int(FbcName) == 4:
                            RbcName = '4'
                        else:
                            SeqIO.write([record], badRecords, 'fastq')
                            continue
                else:    
                    SeqIO.write([record], badRecords, 'fastq')
                    continue
            else:
                matchedRbc = matchedRbcList[0]
                RbcName = RbcDict[matchedRbc]

        #write all four lines for fastq sequence to .fastq file named by barcodes
        outFile = outFilesDict[(FbcName,RbcName)]
        SeqIO.write([record], outFile, 'fastq')

    for key in outFilesDict:        
        outFilesDict[key].close()
    badRecords.close()
    print("Number of special sorts:", SpecialSort)
    return

sortByBarcodes('all_TdT_reads_PassedFilter_Gs.fastq','Barcodes_pCKC021_023_DemultiplexingF.fasta','Barcodes_pCKC021_023_DemultiplexingR.fasta') #order of inputs are the fastq file from HT_assay-2..., then the barcode fasta files
print('done')